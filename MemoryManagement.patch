diff --git a/Makefile b/Makefile
index 39a99d7..597ac8c 100644
--- a/Makefile
+++ b/Makefile
@@ -24,6 +24,7 @@ OBJS = \
   $K/sleeplock.o \
   $K/file.o \
   $K/pipe.o \
+  $K/swap.o \
   $K/exec.o \
   $K/sysfile.o \
   $K/kernelvec.o \
diff --git a/kernel/defs.h b/kernel/defs.h
index a3c962b..c94bff8 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -8,6 +8,7 @@ struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
+struct swap;
 
 // bio.c
 void            binit(void);
@@ -36,6 +37,8 @@ int             filewrite(struct file*, uint64, int n);
 
 // fs.c
 void            fsinit(int);
+uint            balloc(uint dev);
+void            bfree(int dev, uint b);
 int             dirlink(struct inode*, char*, uint);
 struct inode*   dirlookup(struct inode*, char*, uint*);
 struct inode*   ialloc(uint, short);
@@ -63,6 +66,9 @@ void            ramdiskrw(struct buf*);
 void*           kalloc(void);
 void            kfree(void *);
 void            kinit(void);
+void*           kalloc_with_management(void);
+void            kfree_with_management(void *);
+void            manage_pte(pte_t*, void*);
 
 // log.c
 void            initlog(int, struct superblock*);
@@ -107,6 +113,14 @@ int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
 int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
 void            procdump(void);
 
+// swap.c
+void            swapinit(void);
+void            swapfree(struct swap*);
+struct swap*    swapalloc(void);
+void            swapout(struct swap *dst_sp, char *src_pa);
+void            swapin(char *dst_pa, struct swap *src_sp);
+void            swap_out_full(char *p, pte_t *pte);
+
 // swtch.S
 void            swtch(struct context*, struct context*);
 
diff --git a/kernel/fs.c b/kernel/fs.c
index c6bab15..2d9b419 100644
--- a/kernel/fs.c
+++ b/kernel/fs.c
@@ -62,7 +62,7 @@ bzero(int dev, int bno)
 
 // Allocate a zeroed disk block.
 // returns 0 if out of disk space.
-static uint
+uint
 balloc(uint dev)
 {
   int b, bi, m;
@@ -88,7 +88,7 @@ balloc(uint dev)
 }
 
 // Free a disk block.
-static void
+void
 bfree(int dev, uint b)
 {
   struct buf *bp;
diff --git a/kernel/kalloc.c b/kernel/kalloc.c
index 0699e7e..59bdca9 100644
--- a/kernel/kalloc.c
+++ b/kernel/kalloc.c
@@ -8,8 +8,10 @@
 #include "spinlock.h"
 #include "riscv.h"
 #include "defs.h"
+#include "swap.h"
 
 void freerange(void *pa_start, void *pa_end);
+struct live_pages* replace_page(void);
 
 extern char end[]; // first address after kernel.
                    // defined by kernel.ld.
@@ -23,11 +25,21 @@ struct {
   struct run *freelist;
 } kmem;
 
+struct {
+  struct spinlock lock;
+  struct live_pages *head;
+  int num_pages;
+} live_pages;
+
 void
 kinit()
 {
   initlock(&kmem.lock, "kmem");
   freerange(end, (void*)PHYSTOP);
+  initlock(&live_pages.lock, "live_pages");
+  live_pages.head = 0;
+  live_pages.num_pages = 0;
+  free_pool_init();
 }
 
 void
@@ -80,3 +92,52 @@ kalloc(void)
     memset((char*)r, 5, PGSIZE); // fill with junk
   return (void*)r;
 }
+
+void *
+kalloc_with_management(void)
+{
+  void * r = kalloc();
+  if (r == 0) {
+    return 0;
+  }
+  acquire(&live_pages.lock);
+  struct live_pages *new_page = get_free();
+  if(new_page == 0 || live_pages.num_pages == MAXPHYPAGES){
+    new_page = replace_page();
+  }
+  new_page->page = r;
+  new_page->next = 0;
+  new_page->used = 1;
+  live_pages.head = insert_live_page(live_pages.head, new_page);
+  live_pages.num_pages++;
+  release(&live_pages.lock);
+  return r;
+}
+
+void 
+kfree_with_management(void *pa)
+{
+  acquire(&live_pages.lock);
+  live_pages.head = free_live_page(pa, live_pages.head);
+  live_pages.num_pages--;
+  release(&live_pages.lock);
+  kfree(pa);
+}
+
+void manage_pte(pte_t *pte, void *pa)
+{
+  store_pte(pte, pa);
+}
+
+struct live_pages*
+replace_page(void)
+{
+  struct live_pages* rep = find_replacement(live_pages.head, 0);
+  live_pages.head = free_live_page(rep->page, live_pages.head);
+  live_pages.num_pages--;
+  release(&live_pages.lock);
+  swap_out_full(rep->page, rep->pte);
+  kfree_with_management(rep->page);
+  acquire(&live_pages.lock);
+  return get_free();
+}
\ No newline at end of file
diff --git a/kernel/main.c b/kernel/main.c
index f0d3171..ceeb229 100644
--- a/kernel/main.c
+++ b/kernel/main.c
@@ -28,6 +28,7 @@ main()
     iinit();         // inode table
     fileinit();      // file table
     virtio_disk_init(); // emulated hard disk
+    swapinit();      // swap
     userinit();      // first user process
     __sync_synchronize();
     started = 1;
diff --git a/kernel/param.h b/kernel/param.h
index 6624bff..a11435e 100644
--- a/kernel/param.h
+++ b/kernel/param.h
@@ -11,3 +11,4 @@
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
 #define FSSIZE       2000  // size of file system in blocks
 #define MAXPATH      128   // maximum file path name
+#define MAXPHYPAGES  50  // maximum number of physical pages
\ No newline at end of file
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 20a01db..a746391 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -343,6 +343,7 @@ typedef uint64 *pagetable_t; // 512 PTEs
 #define PTE_W (1L << 2)
 #define PTE_X (1L << 3)
 #define PTE_U (1L << 4) // user can access
+#define PTE_S (1L << 8) // swapped
 
 // shift a physical address to the right place for a PTE.
 #define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
diff --git a/kernel/swap.c b/kernel/swap.c
new file mode 100644
index 0000000..5fd5581
--- /dev/null
+++ b/kernel/swap.c
@@ -0,0 +1,148 @@
+#include "types.h"
+#include "riscv.h"
+#include "fs.h"
+#include "spinlock.h"
+#include "defs.h"
+#include "param.h"
+#include "sleeplock.h"
+#include "buf.h"
+
+#define NBLOCKPERPAGE (PGSIZE / BSIZE)
+
+struct swap {
+  uint blocknos[NBLOCKPERPAGE];
+  uint reference_count;
+};
+
+struct run {
+  struct run *next;
+};
+
+struct {
+  struct spinlock lock;
+  struct run *freelist;
+} swapmem;
+
+// Initialize swapmem
+void
+swapinit(void)
+{
+  initlock(&swapmem.lock, "swapmem");
+  swapmem.freelist = 0;
+}
+
+// Allocate one swap struct.
+// Returns a pointer to the swap struct.
+// Returns 0 if the memory cannot be allocated.
+struct swap *
+swapalloc(void)
+{
+  struct run *r;
+  struct swap *s;
+
+  acquire(&swapmem.lock);
+  r = swapmem.freelist;
+  if(!r){
+    release(&swapmem.lock);
+    char *mem = kalloc();
+    char *mem_end = mem + PGSIZE;
+    for(; mem + sizeof(struct swap) <= mem_end; mem += sizeof(struct swap)){
+      r = (struct run*)mem;
+
+      acquire(&swapmem.lock);
+      r->next = swapmem.freelist;
+      swapmem.freelist = r;
+      release(&swapmem.lock);
+    }
+    acquire(&swapmem.lock);
+    r = swapmem.freelist;
+  }
+  swapmem.freelist = r->next;
+  release(&swapmem.lock);
+  
+  s = (struct swap*)r;
+  if(s){
+    memset((char*)s->blocknos, 0, sizeof(s->blocknos)); // fill with zeros
+    s->reference_count = 1;
+  }
+  return s;
+}
+
+// Free the swap struct pointed by s, and the blocks
+// contained in s, which normally should have been returned
+// by a call to swapalloc() and swapout().
+void
+swapfree(struct swap *s)
+{
+  uint *blockno;
+  struct run *r;
+
+  if(!s)
+    panic("swapfree");
+  
+  begin_op();
+  for(blockno = s->blocknos; blockno < &s->blocknos[NBLOCKPERPAGE]; blockno++){
+    if(*blockno)
+      bfree(ROOTDEV, *blockno);
+  }
+  end_op();
+
+  r = (struct run*)s;
+
+  acquire(&swapmem.lock);
+  r->next = swapmem.freelist;
+  swapmem.freelist = r;
+  release(&swapmem.lock);
+}
+
+// Swap out a given physical page src_pa to disk.
+// The metadata for retriving src_pa will be saved
+// to dst_pa which normally should have been returned
+// by a call to swapalloc().
+void
+swapout(struct swap *dst_sp, char *src_pa)
+{
+  uint *blockno;
+  struct buf *bp;
+  
+  begin_op();
+  for(blockno = dst_sp->blocknos; blockno < &dst_sp->blocknos[NBLOCKPERPAGE]; blockno++, src_pa += BSIZE){
+    *blockno = balloc(ROOTDEV);
+    if(*blockno == 0)
+      panic("swapout");
+    bp = bread(ROOTDEV, *blockno);
+    memmove(bp->data, src_pa, BSIZE);
+    log_write(bp);
+    brelse(bp);
+  }
+  end_op();
+}
+
+// Swap in a page into dst_pa from disk using src_sp.
+// src_sp should normally be updated with metadata
+// for retriving the page by a call to swapout().
+void
+swapin(char *dst_pa, struct swap *src_sp)
+{
+  uint *blockno;
+  struct buf *bp;
+  
+  if(!dst_pa)
+    panic("swapin");
+  for(blockno = src_sp->blocknos; blockno < &src_sp->blocknos[NBLOCKPERPAGE]; blockno++, dst_pa += BSIZE){
+    bp = bread(ROOTDEV, *blockno);
+    memmove(dst_pa, bp->data, BSIZE);
+    brelse(bp);
+  }
+}
+
+void
+swap_out_full(char *p, pte_t *pte)
+{
+  struct swap *s;
+  s = swapalloc();
+  if(!s)
+    panic("swap_out_full");
+  swapout(s, p);
+  *pte = (((uint64)s << 10) | PTE_FLAGS(*pte) | PTE_S) & (~PTE_V);
+}
diff --git a/kernel/swap.h b/kernel/swap.h
new file mode 100644
index 0000000..e5062b9
--- /dev/null
+++ b/kernel/swap.h
@@ -0,0 +1,80 @@
+struct live_pages {
+    void* page;
+    struct live_pages *next;
+    int used;
+    pte_t* pte;
+};
+
+struct live_pages free_pool[MAXPHYPAGES];
+
+void free_pool_init()
+{
+    for(int i = 0; i < MAXPHYPAGES; i++){
+        free_pool[i].page = 0;
+        free_pool[i].next = 0;
+        free_pool[i].used = 0;
+    }
+}
+
+struct live_pages* get_free()
+{
+    for(int i = 0; i < MAXPHYPAGES; i++){
+        if(free_pool[i].used == 0){
+            free_pool[i].used = 1;
+            return &free_pool[i];
+        }
+    }
+    return 0;
+}
+
+struct live_pages*
+insert_live_page(struct live_pages *head, struct live_pages *page)
+{
+    if(head == 0){
+        head = page;
+        return head;
+    } 
+    struct live_pages *tmp = head;
+    while(tmp->next != 0){
+        tmp = tmp->next;
+    }
+    tmp->next = page;
+    return head;
+}
+
+
+struct live_pages*
+free_live_page(void* page, struct live_pages *head)
+{
+    struct live_pages *tmp = head;
+    struct live_pages *prev = 0;
+    while(tmp != 0){
+        if(tmp->page == page){
+            tmp->used = 0;
+            if(prev == 0){
+                head = tmp->next;
+            } else {
+                prev->next = tmp->next;
+            }
+            return head;
+        }
+        prev = tmp;
+        tmp = tmp->next;
+    }
+    return head;
+}
+
+struct live_pages*
+find_replacement(struct live_pages *head, int flag)
+{
+    return head;
+}
+
+void store_pte(pte_t *pte, void *page)
+{
+    for(int i = 0; i < MAXPHYPAGES; i++){
+        if(free_pool[i].used == 1 && free_pool[i].page == page){
+            free_pool[i].pte = pte;
+        }
+    }
+}
\ No newline at end of file
diff --git a/kernel/vm.c b/kernel/vm.c
index 9f69783..e72d8ab 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -164,6 +164,14 @@ mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
   return 0;
 }
 
+pte_t *
+get_pte(uint64 va, pagetable_t pagetable)
+{
+  pte_t *pte;
+  pte = walk(pagetable, va, 0);
+  return pte;
+}
+
 // Remove npages of mappings starting from va. va must be
 // page-aligned. The mappings must exist.
 // Optionally free the physical memory.
@@ -185,7 +193,7 @@ uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
       panic("uvmunmap: not a leaf");
     if(do_free){
       uint64 pa = PTE2PA(*pte);
-      kfree((void*)pa);
+      kfree_with_management((void*)pa);
     }
     *pte = 0;
   }
@@ -214,9 +222,11 @@ uvmfirst(pagetable_t pagetable, uchar *src, uint sz)
 
   if(sz >= PGSIZE)
     panic("uvmfirst: more than a page");
-  mem = kalloc();
+  mem = kalloc_with_management();
   memset(mem, 0, PGSIZE);
   mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);
+  pte_t * pte = get_pte(0, pagetable);
+  manage_pte(pte, mem);
   memmove(mem, src, sz);
 }
 
@@ -233,17 +243,19 @@ uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)
 
   oldsz = PGROUNDUP(oldsz);
   for(a = oldsz; a < newsz; a += PGSIZE){
-    mem = kalloc();
+    mem = kalloc_with_management();
     if(mem == 0){
       uvmdealloc(pagetable, a, oldsz);
       return 0;
     }
     memset(mem, 0, PGSIZE);
     if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != 0){
-      kfree(mem);
+      kfree_with_management(mem);
       uvmdealloc(pagetable, a, oldsz);
       return 0;
     }
+    pte_t * pte = get_pte(a, pagetable);
+    manage_pte(pte, mem);
   }
   return newsz;
 }
@@ -317,13 +329,15 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
       panic("uvmcopy: page not present");
     pa = PTE2PA(*pte);
     flags = PTE_FLAGS(*pte);
-    if((mem = kalloc()) == 0)
+    if((mem = kalloc_with_management()) == 0)
       goto err;
     memmove(mem, (char*)pa, PGSIZE);
     if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
-      kfree(mem);
+      kfree_with_management(mem);
       goto err;
     }
+    pte_t * new_pte = get_pte(i, new);
+    manage_pte(new_pte, mem);
   }
   return 0;
 
@@ -437,3 +451,8 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
     return -1;
   }
 }
+
+void uvm_page_swap()
+{
+
+}
